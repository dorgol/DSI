---
title: "Network analysis in R"
output:
  html_document:
    df_print: paged
bibliography: network_analysis_in_R.bib
nocite: | 
  @netCoin18, @ergm08, @ergm18
---

To do?

- Constraints in an ergm
- shortest path analyses, network-based measures of system heterogeneity, and other network characteristics like assortativity

```{r setup, echo=F, cache = T, warning = F, message = F}

# listing major packages once here so you can make sure they're installed
library(dplyr)
library(statnet)
library(lubridate)
library(igraph)
# Most are listed again where first used

# Working directory - upate for your system
wd = "~/Documents/DSI/network_analysis_in_R/"
```
- Degree-corrected SBM can be applied to valued, directed networks. (in R?)

# 2. igraph and VisNetwork

- More algorithmic than model-based. 

- Lots of descriptive statistics and some models too. Many community detection algorithms and many layout options for plots.

- Often better-suited to BIG networks.
    + Random walk-based metrics.f
    + Some methods have options to use sparse matrices. 

`igraph` has a Python version too.

Author: Gabor Csardi (background in computer science, biophysics, statistics)

## Example: Network of Journal Citations

Analyze a network of statistics journals where connections described how much one journal cites another.

Data used is in supplementatry material from a paper available here: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4755202/
In this case we don't have any features about the journals outside the citation counts.

We may be interested in:

- [Visualization of the network](#visualize)
- [Which journals are most important? Which journals are most central in the network?](#centrality)
- [Are there sub-communities of journals?](#community)
- [Other features of the network such as reciprocity](#recipocity)

## A) Convert raw data to a network (igraph) object

Our network comes in the form of a valued adjacency matrix.

We want to retain the information from valued edges wherever possible, instead of reducing it to a binary network.

We remove self-citations by making the diagonal of the adjacency matrix zero. In previous analysis we found that the highest entries in the adjacency matrix are from journals citing themselves, e.g. CSDA (486) and StMed (628). These values could inflate journal importance.

**First we load the data and convert it into a few different `igraph` networks (weighted, binary, undirected)**

```{r journals_load, eval = T, cache = T, echo = T, warning = F, message = F, results = "hide"}

library(igraph)

Cmatrix = as.matrix(read.csv(paste(wd, "RSSA-179-1-s001/Data/cross-citation-matrix.csv", sep = ""), row.names = 1)) #47 x 47
Cmatrix.diag = Cmatrix #store a copy before removing diag
diag(Cmatrix) = rep(0,47)
Tmatrix = Cmatrix + t(Cmatrix)

# We tranpose the Cmatrix to correspond to standard i,j entry = citation FROM i to j. 
# Original Cmatrix has i,j indicating citation from j to i:
Cgraph = graph_from_adjacency_matrix(t(Cmatrix), mode = "directed", weighted = TRUE)
Cgraph.bin = graph_from_adjacency_matrix(t(Cmatrix), mode = "directed", weighted = "citations")
Cgraph.bin.sym = graph_from_adjacency_matrix(Tmatrix, mode = "undirected", weighted = "citations")
Cgraph.sym = graph_from_adjacency_matrix(Tmatrix, mode = "undirected", weighted = TRUE)
```

**Then we look at some basic attributes of the networks to compare and check that they were created correctly**

```{r journals_info, eval = T, cache = T, echo = T, warning = F, message = F}
edge_density(Cgraph)
edge_density(Cgraph.sym)

is.weighted(Cgraph)
is.weighted(Cgraph.bin)

Cgraph.weights = get.edge.attribute(Cgraph, "weight")
#citations is an edge variable in the binary graph, not an edge weight
identical(Cgraph.weights, get.edge.attribute(Cgraph.bin, "citations"))  
```

## B) Visualize {#visualize}

`igraph` has many more layout options than `statnet`. You can use the `intergraph` package to easily convert back and forth (primarily the functions `asIgraph` and `asNetwork`).

```{r journals_plot, eval = T, cache = T, echo = T, warning = F, message = F, fig.height = 12, fig.width = 10, fig.keep = "first", dependson = c("journals_load")}

par(mfrow = c(3,3))
par(mai = rep(.2, 4))

arrow.size = .2
edge.width = .2

plot(Cgraph, edge.arrow.size = arrow.size, edge.arrow.width = arrow.size, edge.width = edge.width,
     layout = layout.grid, main = "layout.grid")
plot(Cgraph, edge.arrow.size = arrow.size, edge.arrow.width = arrow.size, edge.width = edge.width,
     layout = layout.circle, main = "layout.cirlce")
plot(Cgraph, edge.arrow.size = arrow.size, edge.arrow.width = arrow.size, edge.width = edge.width,
     layout = layout.star, main = "layout.star")

plot(Cgraph, edge.arrow.size = arrow.size, edge.arrow.width = arrow.size, edge.width = edge.width,
     layout = layout.davidson.harel, main = "layout.davidson.harel")
plot(Cgraph, edge.arrow.size = arrow.size, edge.arrow.width = arrow.size, edge.width = edge.width,
     layout = layout.graphopt, main = "layout.graphopt")
plot(Cgraph, edge.arrow.size = arrow.size, edge.arrow.width = arrow.size, edge.width = edge.width,
     layout = layout.mds, main = "layout.mds")

plot(Cgraph, edge.arrow.size = arrow.size, edge.arrow.width = arrow.size, edge.width = edge.width,
     layout = layout_nicely, main = "layout_nicely")
plot(Cgraph, edge.arrow.size = arrow.size, edge.arrow.width = arrow.size, edge.width = edge.width,
     layout = layout.auto, main = "layout.fruchterman.reingold")
plot(Cgraph, edge.arrow.size = arrow.size, edge.arrow.width = arrow.size, edge.width = edge.width,
     layout = layout.gem, main = "layout.gem")

# Another way to change the layout
Cgraph <- set_graph_attr(Cgraph, "layout", layout_with_kk(Cgraph))
par(mfrow = c(1,1))
plot(Cgraph, main = "layout_with_kk", edge.arrow.size = arrow.size, edge.arrow.width = arrow.size, edge.width = edge.width)

# Producting/extracting layout coordinates
l = igraph::layout_on_grid(Cgraph)
plot(Cgraph, layout = l)

```

We can tailor the layout to our purposes, which may be visibility of nodes, visualization of clusters, or visibility of relationships. 

```{r journals_statnet, eval = F, cache = T, echo = F, warning = F, message = F}

# If we were using network package: ####
Cnet = as.network(t(Cmatrix), directed=T, matrix.type="a", ignore.eval=F,  
       names.eval="citations") #as valued net, see \cite{krivitsky2015}

#as a binary network
Cbinet <- as.network(t(Cmatrix))

#cited/citing
cited = rowSums(Cmatrix) #citations in
citing = colSums(Cmatrix) #citations out
cite.ratio = cited/citing

#normalized
Cmatrix.norm = t(Cmatrix)/citing #entries are % of i's citations to j (column)
Cnet.norm = as.network(Cmatrix.norm, directed=T, matrix.type="a", ignore.eval=F,
            names.eval="citations")
```

### C) Which journals are most important? {#centrality}

And a related question: which journals are most *central* in the network?

**Centrality and importance in a network are highly related, but not identical.**

<center>![](/Users/janecarlen/Documents/DSI/network_analysis_in_R/newman_networks_7_1.png)</center>
<!--https://books.google.com/books?id=-DgTDAAAQBAJ&pg=PA178&lpg=PA178&dq=%22are+distinguished+by+whether+or+not+they+include+an+additive+constant%22&source=bl&ots=PB-ZimlUJP&sig=UfBughQwBb3_mEFY-C9zxUpgM00&hl=en&sa=X&ved=2ahUKEwjWm8iDlNfeAhUumeAKHdQ2Dw4Q6AEwAHoECAAQAQ#v=onepage&q&f=false-->

`igraph` has several built-in metrics related to both

- Degree centrality is just the number or weight of a node's edges. 
- Betweenness centrality of a vertex is the number of geodesics (shortest paths) going through it.

```{r journals_importance, eval = F, cache = T, echo = T, warning = F, message = F}

par(mfrow = c(1,2))

cen.between.bin = estimate_betweenness(Cgraph.bin, vids = V(Cgraph), directed = TRUE, cutoff = Inf, weights = NULL)
round(sort(cen.between.bin, decreasing = T))                   
plot(degree(Cgraph.bin), cen.between.bin)
text(degree(Cgraph.bin), cen.between.bin, labels = rownames(Cmatrix))

cen.between = estimate_betweenness(Cgraph, vids = V(Cgraph), directed = TRUE, cutoff = Inf, weights = 1 + max(Cgraph.weights) - Cgraph.weights)
round(sort(cen.between, decreasing = T))                   
plot(degree(Cgraph), cen.between)
```

### D) Are there sub-communities of journals {#community}

Most common clustering algorithms expect undirected graphs. Community membership is a symmetric characteristic.

Degree-corrected SBM can be applied to valued, directed networks.

The following plots compare output of the different clustering algorithms by coloring the nodes accordingly

- Fast greedy (`cluster_fast_greedy`):

- Louvain modularity maximization (`cluster_louvain`):

- Leading Eigenvalue (`cluster_leading_eigen`):

- Infomap (`cluster_infomap`):
  + 

- Walktrap (cluster_walktrap): 
  + Works with directed networks. 
  + 
```{r journals_cluster, cache = T, eval = T, echo = T, fig.width = 12}

set.seed(1)
l = layout_with_fr(Cgraph)

cl.membership.infomap = cluster_infomap(Cgraph.sym, e.weights = Cgraph.sym.weights)$membership 
cl.membership.louvain = cluster_louvain(Cgraph.sym, weights = Cgraph.sym.weights)$membership 
cl.membership.fast_greedy = cluster_fast_greedy(Cgraph.sym, weights = Cgraph.sym.weights)$membership 
# cluster_fast_greedy(Cgraph.sym) # Defaults to use weights
cl.membership.bin.fast_greedy = cluster_fast_greedy(Cgraph.bin.sym)$membership 
cl.membership.eigen = cluster_leading_eigen(Cgraph.sym)$membership 
cl.membership.walktrap = cluster_walktrap(Cgraph, weights = Cgraph.weights)$membership  #will default to use weights anyway

# A hacky way to relevel the membership vectors so they agree
for (elem in ls()[str_detect(ls(), "^cl\\.membership")]) {
  assign(elem, as.numeric(relevel(as.factor(get(elem)), ref = get(elem)[1])))
}

  
#plot
par(mfrow = c(2,3))
par(mai = rep(.2, 4))

plot(Cgraph.sym, vertex.color = cl.membership.louvain, main = "Louvain", layout = l)
plot(Cgraph.sym, vertex.color = cl.membership.eigen, main = "Eigen", layout = l)
plot(Cgraph.sym, vertex.color = cl.membership.fast_greedy, main = "Fast Greedy", layout = l)

plot(Cgraph.sym, vertex.color = cl.membership.bin.fast_greedy, main = "Binary Fast Greedy", layout = l)
plot(Cgraph.sym, vertex.color = cl.membership.infomap, main = "Infomap", layout = l)
plot(Cgraph, vertex.color = cl.membership.walktrap, main = "Walktrap", layout = l, edge.arrow.size = .3, edge.arrow.width = .3)


```


### E) Other features of the network {#reciprocity}

- Reciprocity: 
  The `reciprocity` method in `igraph` assumes a binary network.
  + `default`: $sum(i, j, (A.*A')_{ij}) / sum(i, j, A_{ij})$, where $A.*A'$ is the element-wise product of matrix A and its transpose. 
  + `ratio`: percentage of reciprocated ties 
  To account for valued netwworks can can use a simple correlation measure.
```{r journals_reciprocity, eval = T, cache = T}

# Create a binary matrix and symmetric total matrix for later
Cmatrix.bin <- as_adjacency_matrix(Cgraph.bin, sparse = F)

# Reciprocity
reciprocity(Cgraph, ignore.loops = TRUE, mode = c("default"))
mean(Cmatrix.bin*t(Cmatrix.bin))/mean(Cmatrix.bin)
# Can also use a simple correlation measure
cor(as.vector(Cmatrix), as.vector(t(Cmatrix)))

reciprocity(Cgraph, ignore.loops = TRUE, mode = c("ratio"))
mean(Cmatrix.bin*t(Cmatrix.bin))/mean(Tmatrix>0)
```


- Assortativity:
    + by degree: Do higher-degree nodes connect to other higher degree nodes? $sum_{jl}(e(j,k)-qout(j)qin(k)), j, k) / sigma(qin) / sigma(qout)
      
    + by characteristic: Since we don't have nodal charactersitics we'll use communities to illustrate
 
```{r journals_assortativity, eval = T, cache = T}

# Assortativity
assortativity_degree(Cgraph, directed = T)
assortativity_nominal(Cgraph, types = cl.membership.louvain, directed = T)

```

   
- Clustering coefficient

```{r setup_jrss, eval = F, cache = F, echo = F, results='hide', warning=F, echo = F, message=F, dependson = "setup"}
#code from JRSS-PR-SA-Dec-13-0008_supplement.R to the paper
journal.abbr <- rownames(Cmatrix)

journals.cluster <- hclust(d = as.dist(1 - cor(Tmatrix)))
#plot(journals.cluster, sub = "", xlab = "")
#cutree(journals.cluster, h = 0.6)  
library(BradleyTerry2)

Cdata <- countsToBinomial(Cmatrix)
fit <- BTm(outcome = cbind(win1, win2), player1 = player1, player2 = player2, data = Cdata)

npairs <- NROW(Cdata)
njournals <- nlevels(Cdata$player1)
phi <- sum(residuals(fit, "pearson")^2) / (npairs - (njournals - 1))

## 3.1 Journal residuals
journal.res <- rep(NA, njournals)
res <- residuals(fit, type = "pearson")
coefs <- c(0, coef(fit)) # 0 is the coefficient of the first journal
for(i in 1:njournals){
    A <- which(Cdata$player1 == journal.abbr[i])
    B <- which(Cdata$player2 == journal.abbr[i])
    y <- c(res[A], -res[B])
    x <- c(-coefs[Cdata$player2[A]], -coefs[Cdata$player1[B]])
    journal.res[i] <- sum(y * x) / sqrt(phi * sum(x ^ 2))
}
names(journal.res) <- journal.abbr

library(qvcalc)
cov.matrix <- matrix(0, nrow = njournals, ncol = njournals)
cov.matrix[-1, -1] <- vcov(fit)
qse <- qvcalc(phi * cov.matrix, estimates = c(0, coef(fit)),
              labels = journal.abbr)
#qse[["covmat"]] = cov.matrix*phi

export.scores <- qse$qvframe$estimate
export.scores <- export.scores - mean(export.scores)
names(export.scores) <- journal.abbr

sort.id <- sort(export.scores, decreasing = TRUE, index.return = TRUE)$ix
fit.table <- data.frame(quasi = export.scores[sort.id], qse = qse$qvframe$quasiSE[sort.id])
rownames(fit.table)
rownames(fit.table)[c(1,6,20)] = c("JRSS-B", "JRSS-A", "JRSS-C")
match(rownames(fit.table),Cnet%v%"vertex.names")
fit.table2 = fit.table[order(match(rownames(fit.table),Cnet%v%"vertex.names")),]
```

 
- Metrics like minimum path lengths between vertices can be slow to calculate. There are packages such as `fastnet` which can do these calculations fast using parallelization and sampling @fastnet18.


# 3. Latentnet
 
 My favorite : )
 
- Unobserved (social) space
- "Enough" parameters to describe the behavior (no degeneracy)
- Latent space network models produce model-based visualizations.
- A residual measure of what is not captured by dyad-independent terms. 



#  References


